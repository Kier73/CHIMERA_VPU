#pragma once

#include <string>
#include <vector>
#include <map>
#include <memory>

// --- Pillar 2 Data Structures ---

// Quantifies the "Arbitrary Contextual Weight" (ACW) of the data.
struct DataProfile {
    // For binary data (Weight-Flux Computing)
    uint64_t hamming_weight = 0;
    double sparsity_ratio = 1.0; // 1.0 = all zeros, 0.0 = all ones

    // For numerical data (Omnimorphic)
    double amplitude_flux = 0.0;
    double frequency_flux = 0.0;
    double entropy_flux = 0.0;

    // IoT Sensor Data
    double power_draw_watts = 0.0;
    double temperature_celsius = 0.0;
    double network_latency_ms = 0.0;
    double network_bandwidth_mbps = 0.0;
    double io_throughput_mbps = 0.0;
    double data_quality_score = 1.0; // Default to perfect quality
};

// Contains all information for the Orchestrator to make a decision.
struct EnrichedExecutionContext {
    std::shared_ptr<const DataProfile> profile;
    std::string task_type;
};

// --- Pillar 3 Data Structures ---

// Represents a single step in a potential execution plan.
struct ExecutionStep {
    std::string operation_name;  // e.g., "FFT_FORWARD", "CONV_DIRECT", "JIT_GENERATE_SAXPY"
    std::string input_buffer_id;
    std::string output_buffer_id;
};

// The definitive, step-by-step recipe for execution generated by Pillar 3.
struct ExecutionPlan {
    std::string chosen_path_name;
    double predicted_holistic_flux = 0.0;
    std::vector<ExecutionStep> steps;
};

// --- Pillar 5 Data Structures ---

// The ground-truth record of what happened during execution.
struct ActualPerformanceRecord {
    double observed_latency_ns = 0.0; // Renamed from observed_holistic_flux
    uint64_t observed_cycle_cost = 0;
    uint64_t observed_hw_in_cost = 0;
    uint64_t observed_hw_out_cost = 0;
    double observed_holistic_flux = 0.0; // Will be sum of cycle + hw_in + hw_out costs
};

// Key information for the learning algorithm to pinpoint the source of an error.
struct LearningContext {
    std::string path_name;
    std::string transform_key;
    std::string operation_key; // For sensitivity (lambda) learning
    std::string main_operation_name; // For base_operational_cost learning
};
